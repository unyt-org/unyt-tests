import { TestRunner } from "../core/test_runner.ts";
import { Datex } from "unyt_core";
import { TestManager } from "../core/test_manager.ts";
import { Path } from "unyt_node/path.ts";

import { type DocNode } from "https://deno.land/x/deno_doc@0.58.0/lib/types.d.ts";
const doc = globalThis.Deno ? (await import("https://deno.land/x/deno_doc@0.58.0/mod.ts")).doc : null;

/**
 * Runs TypeScript/JavaScript tests in deno/browser worker context
 */


@TestRunner.Config({
	fileExtensions: ['ts', 'js', 'tsx', 'jsx']
})
export class TypescriptTestRunner extends TestRunner {

	protected async handleLoadStatic(context: URL) {

		if (!doc) return;

		// empty file to trick doc module resolver (?)
		const mockDir = await Deno.makeTempDir();
		const mockFile = new Path(mockDir).asDir().getChildPath("void.ts");
		await Deno.writeTextFile(mockFile, "")

		const docs = await doc(context.toString(), {
			includeAll: true,
			resolve: (specifier:string) => {
				// console.log("resolve " +specifier, mockFile.toString());
				return mockFile.toString()
			},
			load: async (specifier, isDynamic) => {
				// console.log("load " +specifier);
				if (specifier.startsWith("file://")) {
					try {
						return {kind:"module", specifier, content: await Deno.readTextFile(new URL(specifier))};
					} catch (e) {console.log(e);return undefined}
				}
				else return {kind:"module", specifier: "http://ignore/ignore.ts", content: ""};
			}
			// importMap: "https://dev.cdn.unyt.org/importmap.json"
		});

		const staticTestInfo = this.extractTestDataFromDocData(docs);

		TestManager.registerContext(context);

		// load tests
		for (const {name:groupName, testCases} of staticTestInfo) {
			TestManager.registerTestGroup(context, groupName.toString())
			for (const {name, args} of testCases) {
				await TestManager.registerTestCase(context, groupName.toString(), name.toString(), args ? new Array<any[]>(args.length).fill([]) : []);
			}
		}
		
	}	

	/**
	 * convert the docNodes generated by the deno doc generator to an array of test group data
	 * @param docNodes DocNode[] generated by deno_doc
	 * @returns 
	 */
	private extractTestDataFromDocData(docNodes:DocNode[]) {
		const testsGroups = [];
		// get classes (groups)
		for (const node of docNodes) {
			if (node.kind == "class") {
				const testCases = [];

				// get class methods (test cases)
				for (const el of node.classDef.methods) {
					for (const d of el.functionDef.decorators??[]) {
						if (d.name == "Test") {
							testCases.push({name: el.name, args: d.args});
							break;
						}
					}
				}

				testsGroups.push({
					name: node.name,
					testCases
				})
			}
		}
		return testsGroups;
	}

	protected async handleLoad(path: URL, endpoint:Datex.Endpoint) {
		const env = {
			test_manager: Datex.Runtime.endpoint.toString(), 
			endpoint: endpoint.toString(),
			context: path.toString(),
			supranet_connect: TestManager.SUPRANET_CONNECT.toString()
		};

		const worker = new Worker(path, {
			type: "module"
		});

		await loaded(worker); // worker emits "loaded" message
		worker.postMessage(env); // set env data
	}
	
}

const loaded = (w:Worker) => new Promise(r => w.addEventListener("message", r, { once: true }));